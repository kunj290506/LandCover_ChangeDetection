<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TerraSense | Insight from Orbit</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #FFFFFF;
            --text-main: #111111;
            --text-sub: #666666;
            --accent: #111111;
            /* Carbon Black for high contrast */
            --border: #E5E5E5;
            --surface: #FAFAFA;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
        }

        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            overflow-x: hidden;
            line-height: 1.5;
        }

        /* Nav */
        nav {
            padding: 32px 48px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: -0.02em;
            text-transform: uppercase;
        }

        .nav-link {
            text-decoration: none;
            color: var(--text-main);
            font-size: 14px;
            font-weight: 500;
            border: 1px solid var(--border);
            padding: 10px 24px;
            border-radius: 99px;
            transition: all 0.2s;
        }

        .nav-link:hover {
            background: var(--text-main);
            color: white;
            border-color: var(--text-main);
        }

        /* Cursor */
        .cursor-dot,
        .cursor-outline {
            position: fixed;
            top: 0;
            left: 0;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            z-index: 9999;
            pointer-events: none;
        }

        .cursor-dot {
            width: 8px;
            height: 8px;
            background-color: var(--text-main);
        }

        .cursor-outline {
            width: 40px;
            height: 40px;
            border: 1px solid var(--text-main);
            transition: width 0.2s, height 0.2s, background-color 0.2s;
        }

        /* Hero */
        .hero {
            min-height: 90vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 120px 48px 0;
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            font-size: clamp(48px, 8vw, 120px);
            font-weight: 300;
            letter-spacing: -0.04em;
            line-height: 0.95;
            margin-bottom: 48px;
            color: var(--text-main);
        }

        .hero-footer {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: end;
            gap: 40px;
        }

        .hero-desc {
            font-size: 18px;
            color: var(--text-sub);
            max-width: 400px;
        }

        .cta-big {
            display: block;
            background: var(--text-main);
            color: white;
            text-decoration: none;
            padding: 24px 48px;
            font-size: 18px;
            border-radius: 4px;
            text-align: center;
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            justify-self: end;
        }

        .cta-big:hover {
            transform: translateY(-5px);
        }

        /* Divider */
        hr {
            border: none;
            border-top: 1px solid var(--border);
            margin: 0 48px;
        }

        /* Grid Section */
        .grid-section {
            padding: 120px 48px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 24px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .feature-box {
            background: var(--surface);
            padding: 48px;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            transition: background 0.3s;
        }

        .feature-box:hover {
            background: #F0F0F0;
        }

        .feature-num {
            font-size: 12px;
            color: var(--text-sub);
            padding-bottom: 24px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        .feature-title {
            font-size: 32px;
            font-weight: 400;
            letter-spacing: -0.03em;
            margin-top: auto;
        }

        /* How it Works Section */
        .how-it-works {
            padding: 120px 48px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .section-title {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 60px;
            display: block;
            border-bottom: 1px solid var(--border);
            padding-bottom: 20px;
        }

        .steps-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 40px;
            margin-bottom: 120px;
        }

        .step-card h3 {
            font-size: 24px;
            font-weight: 500;
            margin: 20px 0 10px;
        }

        .step-card p {
            color: var(--text-sub);
            font-size: 15px;
            line-height: 1.6;
        }

        .step-image {
            width: 100%;
            aspect-ratio: 4/3;
            background: var(--surface);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid var(--border);
            position: relative;
        }

        .step-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .step-card:hover .step-image img {
            transform: scale(1.05);
        }

        /* Footer */
        footer {
            padding: 80px 48px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        .footer-brand {
            font-size: 14vw;
            font-weight: 600;
            letter-spacing: -0.06em;
            line-height: 0.8;
            opacity: 0.05;
            user-select: none;
            pointer-events: none;
            margin-left: -1vw;
        }

        .links {
            display: flex;
            gap: 32px;
        }

        .links a {
            color: var(--text-sub);
            text-decoration: none;
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .hero {
                padding: 100px 24px 0;
                min-height: auto;
            }

            h1 {
                font-size: 14vw;
                margin-bottom: 32px;
            }

            .hero-footer {
                grid-template-columns: 1fr;
            }

            .cta-big {
                width: 100%;
            }

            .how-it-works {
                padding: 60px 24px;
            }

            .grid-section {
                padding: 60px 24px;
                grid-template-columns: 1fr;
            }

            nav {
                padding: 20px 24px;
            }

            .cursor-dot,
            .cursor-outline {
                display: none;
            }

            /* Hide custom cursor on touch */
        }

        /* New Tech-Heavy Styles */
        .tech-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 60px;
            padding: 120px 48px;
            max-width: 1600px;
            margin: 0 auto;
            align-items: center;
        }

        .info-col h2 {
            font-size: 40px;
            font-weight: 500;
            margin-bottom: 24px;
            letter-spacing: -0.02em;
        }

        .info-col p {
            font-size: 16px;
            color: var(--text-sub);
            line-height: 1.7;
            margin-bottom: 24px;
        }

        .stat-row {
            display: flex;
            gap: 48px;
            margin-top: 40px;
        }

        .stat-item .val {
            font-size: 32px;
            font-weight: 600;
            display: block;
            margin-bottom: 4px;
        }

        .stat-item .label {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-sub);
        }

        /* Generative Canvas Container */
        .canvas-container {
            width: 100%;
            height: 500px;
            background: #FAFAFA;
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        .overlay-text {
            position: absolute;
            font-family: monospace;
            font-size: 12px;
            color: rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }

        /* Feature Cards (No Images) */
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 24px;
            max-width: 1600px;
            margin: 0 auto;
            padding: 0 48px 120px;
        }

        .tech-card {
            border: 1px solid var(--border);
            padding: 40px;
            background: white;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .tech-card:hover {
            border-color: var(--text-main);
            transform: translateY(-4px);
        }

        .tech-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--text-main);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.3s ease;
        }

        .tech-card:hover::before {
            transform: scaleX(1);
        }

        .tech-icon {
            font-size: 24px;
            margin-bottom: 24px;
            font-family: monospace;
        }

        .tech-card h3 {
            font-size: 20px;
            margin-bottom: 12px;
            font-weight: 500;
        }

        .tech-card p {
            font-size: 14px;
            color: var(--text-sub);
            line-height: 1.6;
        }
    </style>
</head>

<body>
    <!-- Custom Cursor -->
    <div class="cursor-dot"></div>
    <div class="cursor-outline"></div>

    <nav>
        <div class="logo">TerraSense AI</div>
        <!-- Link to the main app file -->
        <a href="app.html" class="nav-link">Launch App</a>
    </nav>

    <div class="hero">
        <canvas id="heroCanvas"
            style="position: absolute; top:0; left:0; width:100%; height:100%; z-index:-1; opacity: 0.4;"></canvas>
        <div style="position: relative; z-index: 2;">
            <h1>Detect<br>Global Change<br>Instantly.</h1>
            <div class="hero-footer">
                <p class="hero-desc">
                    Leveraging <strong>Siamese Nested U-Net (SNUNet-CD)</strong> architects to perform pixel-level
                    change detection on bitemporal satellite imagery.
                </p>
                <a href="app.html" class="cta-big">Start Analysis -></a>
            </div>
        </div>
    </div>

    <hr>

    <!-- Detailed Tech Section -->
    <section class="tech-grid">
        <div class="info-col">
            <h2>Deep Learning Architecture</h2>
            <p>
                TerraSense utilizes a state-of-the-art <strong>SNUNet-CD</strong> model. Unlike traditional
                difference-based methods, our model employs a densely connected Siamese neural network to extract
                multi-scale features.
            </p>
            <p>
                The <strong>Ensemble Channel Attention Module (ECAM)</strong> refines these features, allowing the
                system to distinguish between actual semantic changes (construction, deforestation) and seasonal
                variations or shadow shifts.
            </p>
            <div class="stat-row">
                <div class="stat-item">
                    <span class="val">98.4%</span>
                    <span class="label">F1-Score</span>
                </div>
                <div class="stat-item">
                    <span class="val">0.2s</span>
                    <span class="label">Inference Time</span>
                </div>
                <div class="stat-item">
                    <span class="val">256px</span>
                    <span class="label">Tile Size</span>
                </div>
            </div>
        </div>
        <div class="canvas-container">
            <canvas id="networkCanvas"></canvas>
            <div class="overlay-text" style="top: 20px; left: 20px;">MODEL_ARCH: SNUNET-CD</div>
            <div class="overlay-text" style="bottom: 20px; right: 20px;">STATUS: ACTIVE</div>
        </div>
    </section>

    <!-- LIVE SIMULATION SECTION -->
    <section class="tech-grid" style="background: var(--surface);">
        <div class="canvas-container">
            <canvas id="simCanvas"></canvas>
            <div class="overlay-text" style="top: 20px; left: 20px;">INPUT: OPTICAL SATELLITE</div>
            <div class="overlay-text" style="bottom: 20px; right: 20px;">OUTPUT: CHANGE MASK</div>
        </div>
        <div class="info-col">
            <h2>Real-Time Detection</h2>
            <p>
                Our model processes bitemporal imagery in milliseconds. Watch as the <strong>SNUNet-CD</strong> engine
                scans the landscape, instantly segmenting new construction and terrain changes.
            </p>
            <p>
                The output is a precise binary maskâ€”white pixels represent confirmed change, ready for vectorization and
                GIS integration.
            </p>
            <a href="app.html" class="nav-link" style="display: inline-block; margin-top: 16px;">Try Your Own Data
                -></a>
        </div>
    </section>

    <!-- Text-Only Technical Use Cases -->
    <div class="section-title" style="margin: 0 48px 60px;">System Capabilities</div>
    <section class="feature-grid">
        <div class="tech-card">
            <div class="tech-icon">[ 01 ]</div>
            <h3>Urbanization Monitoring</h3>
            <p>
                Automatically identify new building footprints and road networks. Essential for municipal planning,
                zoning enforcement, and population density estimation.
            </p>
        </div>
        <div class="tech-card">
            <div class="tech-icon">[ 02 ]</div>
            <h3>Vegetation Analysis</h3>
            <p>
                Quantify deforestation rates and canopy loss. Calculates precise vegetation indices (NDVI) differences
                to report environmental impact metrics.
            </p>
        </div>
        <div class="tech-card">
            <div class="tech-icon">[ 03 ]</div>
            <h3>Disaster Assessment</h3>
            <p>
                Rapid response mapping for flood extent and earthquake damage. compares pre-event and post-event imagery
                to guide relief efforts effectively.
            </p>
        </div>
    </section>

    <footer>
        <div class="links">
            <a href="#">Github</a>
            <a href="#">Whitepaper</a>
            <a href="#">Model Weights</a>
        </div>
        <div class="footer-brand">TERRA</div>
    </footer>

    <script>
        // Cursor Logic
        const cursorDot = document.querySelector('.cursor-dot');
        const cursorOutline = document.querySelector('.cursor-outline');

        window.addEventListener('mousemove', (e) => {
            const posX = e.clientX;
            const posY = e.clientY;

            cursorDot.style.left = `${posX}px`;
            cursorDot.style.top = `${posY}px`;

            // smooth trailer
            cursorOutline.animate({
                left: `${posX}px`,
                top: `${posY}px`
            }, { duration: 500, fill: "forwards" });
        });

        // Hover Effect specific
        document.querySelectorAll('a, button').forEach(el => {
            el.addEventListener('mouseenter', () => {
                cursorOutline.style.width = '60px';
                cursorOutline.style.height = '60px';
                cursorOutline.style.backgroundColor = 'rgba(0,0,0,0.05)';
            });
            el.addEventListener('mouseleave', () => {
                cursorOutline.style.width = '40px';
                cursorOutline.style.height = '40px';
                cursorOutline.style.backgroundColor = 'transparent';
            });
        });

        // --- Generative Art: Hero Particles ---
        const heroCanvas = document.getElementById('heroCanvas');
        const ctxHero = heroCanvas.getContext('2d');
        let width, height;
        let particles = [];

        function resizeHero() {
            width = heroCanvas.width = window.innerWidth;
            height = heroCanvas.height = window.innerHeight;
            initParticles();
        }

        function initParticles() {
            particles = [];
            for (let i = 0; i < 100; i++) {
                particles.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    size: Math.random() * 2
                });
            }
        }

        function drawHero() {
            ctxHero.clearRect(0, 0, width, height);
            ctxHero.fillStyle = '#111';
            ctxHero.strokeStyle = 'rgba(0,0,0,0.05)';

            particles.forEach((p, i) => {
                p.x += p.vx;
                p.y += p.vy;

                if (p.x < 0 || p.x > width) p.vx *= -1;
                if (p.y < 0 || p.y > height) p.vy *= -1;

                ctxHero.beginPath();
                ctxHero.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctxHero.fill();

                // Connect
                particles.forEach((p2, j) => {
                    if (i === j) return;
                    const dx = p.x - p2.x;
                    const dy = p.y - p2.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 150) {
                        ctxHero.beginPath();
                        ctxHero.moveTo(p.x, p.y);
                        ctxHero.lineTo(p2.x, p2.y);
                        ctxHero.stroke();
                    }
                });
            });
            requestAnimationFrame(drawHero);
        }

        window.addEventListener('resize', resizeHero);
        resizeHero();
        drawHero();

        // --- Generative Art: Neural Network Viz ---
        const netCanvas = document.getElementById('networkCanvas');
        const ctxNet = netCanvas.getContext('2d');
        let netW, netH, nodes = [];

        function resizeNet() {
            // Get parent size
            const rect = netCanvas.parentElement.getBoundingClientRect();
            netW = netCanvas.width = rect.width;
            netH = netCanvas.height = rect.height;
            initNet();
        }

        function initNet() {
            nodes = [];
            const layers = 5;
            const nodesPerLayer = [4, 6, 8, 6, 4];
            const layerGap = netW / (layers + 1);

            nodesPerLayer.forEach((count, lIndex) => {
                const x = (lIndex + 1) * layerGap;
                const yGap = netH / (count + 1);
                for (let i = 0; i < count; i++) {
                    nodes.push({
                        x: x,
                        y: (i + 1) * yGap,
                        active: Math.random() > 0.5
                    });
                }
            });
        }

        function drawNet() {
            ctxNet.clearRect(0, 0, netW, netH);

            // Draw connections
            ctxNet.lineWidth = 1;
            nodes.forEach((node, i) => {
                nodes.forEach((node2, j) => {
                    // distinct layer connection logic simplified for visual
                    const dx = Math.abs(node.x - node2.x);
                    if (dx > 0 && dx < netW / 4) { // adjacent layers mostly
                        const dist = Math.hypot(node.x - node2.x, node.y - node2.y);
                        if (dist < 200) {
                            ctxNet.strokeStyle = `rgba(0,0,0,${0.1 - (dist / 2000)})`;
                            ctxNet.beginPath();
                            ctxNet.moveTo(node.x, node.y);
                            ctxNet.lineTo(node2.x, node2.y);
                            ctxNet.stroke();
                        }
                    }
                });
            });

            // Draw Nodes
            nodes.forEach(node => {
                ctxNet.fillStyle = node.active ? '#111' : '#ddd';
                ctxNet.beginPath();
                ctxNet.arc(node.x, node.y, 4, 0, Math.PI * 2);
                ctxNet.fill();

                // Pulse
                if (node.active && Math.random() > 0.95) {
                    ctxNet.strokeStyle = '#111';
                    ctxNet.beginPath();
                    ctxNet.arc(node.x, node.y, 10, 0, Math.PI * 2);
                    ctxNet.stroke();
                }
            });

            if (Math.random() > 0.9) nodes.forEach(n => n.active = Math.random() > 0.5);

            requestAnimationFrame(drawNet);
        }

        // Init Net after load to ensure container size
        setTimeout(() => {
            resizeNet();
            drawNet();
            resizeSim();
            drawSim();
        }, 100);

        // --- Generative Art: Result Simulation ---
        const simCanvas = document.getElementById('simCanvas');
        const ctxSim = simCanvas.getContext('2d');
        let simW, simH;
        let buildings = [];
        let scanX = 0;

        function resizeSim() {
            const rect = simCanvas.parentElement.getBoundingClientRect();
            simW = simCanvas.width = rect.width;
            simH = simCanvas.height = rect.height;
            initSimMap();
        }

        function initSimMap() {
            buildings = [];
            // Procedural City
            for (let i = 0; i < 40; i++) {
                buildings.push({
                    x: Math.random() * simW,
                    y: Math.random() * simH,
                    w: 20 + Math.random() * 60,
                    h: 20 + Math.random() * 60,
                    isChange: Math.random() > 0.3 // 70% chance to be "changed" (new building)
                });
            }
        }

        function drawSim() {
            ctxSim.clearRect(0, 0, simW, simH);

            // 1. Draw Satellite View (Background)
            ctxSim.fillStyle = '#e0e0e0'; // Earth base
            ctxSim.fillRect(0, 0, simW, simH);

            // Draw "Old" buildings (grey)
            ctxSim.fillStyle = '#bbb';
            buildings.forEach(b => {
                if (!b.isChange) ctxSim.fillRect(b.x, b.y, b.w, b.h);
            });

            // Draw "New" buildings as if they are just construction sites in input (brown/dirt)
            ctxSim.fillStyle = '#dcb';
            buildings.forEach(b => {
                if (b.isChange) ctxSim.fillRect(b.x, b.y, b.w, b.h);
            });

            // 2. Draw Mask View (Revealed by Scan)
            // We use clipping to show the mask ONLY behind the scan line
            ctxSim.save();
            ctxSim.beginPath();
            ctxSim.rect(0, 0, scanX, simH);
            ctxSim.clip();

            // Mask Background (Black)
            ctxSim.fillStyle = '#111';
            ctxSim.fillRect(0, 0, simW, simH);

            // Mask Foreground (White for Change)
            ctxSim.fillStyle = '#fff';
            buildings.forEach(b => {
                if (b.isChange) ctxSim.fillRect(b.x, b.y, b.w, b.h);
            });
            ctxSim.restore();

            // 3. Draw Scan Line
            ctxSim.strokeStyle = '#00ff00';
            ctxSim.lineWidth = 2;
            ctxSim.beginPath();
            ctxSim.moveTo(scanX, 0);
            ctxSim.lineTo(scanX, simH);
            ctxSim.stroke();

            // Animate Scan
            scanX += 2;
            if (scanX > simW + 50) {
                scanX = 0;
                initSimMap(); // New map every cycle
            }

            requestAnimationFrame(drawSim);
        }

        window.addEventListener('resize', resizeSim);

    </script>
</body>

</html>